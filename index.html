<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VCTR - LQDPXL - Liquid Pixels</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%;
      background: #000;
      color: #fff;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }

    body, .container {
      width: 100vw; height: 100vh;
    }

    .container {
      position: relative;
      width: 100vw; height: 100vh;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    .header {
      position: absolute;
      top: 20px; left: 20px;
      z-index: 100;
      font-size: 2rem;
      font-weight: bold;
      letter-spacing: 3px;
      text-shadow: 0 0 20px #00ffff;
      animation: glow 2s ease-in-out infinite alternate;
      pointer-events: none;
    }
    @keyframes glow {
      from { text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff; }
      to   { text-shadow: 0 0 30px #ff00ff, 0 0 40px #ff00ff; }
    }

    .info {
      position: absolute;
      bottom: 20px; right: 20px;
      z-index: 100;
      font-size: 0.85rem;
      opacity: 0.8;
      text-align: right;
      pointer-events: none;
      letter-spacing: 1px;
    }

    .controls {
      position: absolute;
      bottom: 20px; left: 20px;
      z-index: 100;
      font-size: 0.93rem;
      opacity: 0.92;
      background: rgba(0,0,0,0.5);
      border-radius: 8px;
      padding: 0.7em 1em;
      pointer-events: none;
      letter-spacing: 1px;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at center, #191c22 0%, #000 100%);
      cursor: grab;
      transition: cursor 0.2s;
    }
    canvas:active {
      cursor: grabbing;
    }

    .ripple {
      position: absolute;
      left: 50%; top: 50%;
      width: 24px; height: 24px;
      pointer-events: none;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, #00ffff 70%, transparent 100%);
      opacity: 0.6;
      transform: translate(-50%, -50%) scale(0.6);
      animation: ripple 0.5s cubic-bezier(.3,.7,.4,1) forwards;
      z-index: 999;
    }
    @keyframes ripple {
      to {
        opacity: 0;
        transform: translate(-50%, -50%) scale(2.8);
      }
    }

    @media (max-width: 768px) {
      .header { font-size: 1.5rem; top: 10px; left: 10px;}
      .info { font-size: 0.72rem; bottom: 10px; right: 10px;}
      .controls { font-size: 0.79rem; bottom: 10px; left: 10px;}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">LQDPXL</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
      <span style="color:#00ffc3">Click</span>
      <span style="opacity:0.7;">to spawn a vector from the origin.<br>
      <span style="color:#92f">Drag</span> to rotate space.</span>
    </div>
    <div class="info">
      LIQUID PIXELS<br>
      3D VECTOR SPACE<br>
      RGB CUBE MAPPING
    </div>
  </div>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height, centerX, centerY;
    let time = 0;
    let vectors = [];
    let endpoints = [];
    let rotationX = -0.45;
    let rotationY = -0.7;
    let mouseDown = false;
    let lastMouseX = 0, lastMouseY = 0;
    let isTouch = false;

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      centerX = width / 2;
      centerY = height / 2;
    }

    function rotateX(point, angle) {
      const cos = Math.cos(angle), sin = Math.sin(angle);
      return { x: point.x, y: point.y * cos - point.z * sin, z: point.y * sin + point.z * cos };
    }
    function rotateY(point, angle) {
      const cos = Math.cos(angle), sin = Math.sin(angle);
      return { x: point.x * cos + point.z * sin, y: point.y, z: -point.x * sin + point.z * cos };
    }
    function project3D(x, y, z) {
      let point = {x,y,z};
      point = rotateX(point, rotationX);
      point = rotateY(point, rotationY);
      const distance = 520;
      const scale = distance / (distance + point.z);
      return {
        x: centerX + point.x * scale,
        y: centerY - point.y * scale,
        scale: scale
      };
    }

    // RGB CUBE COLOR MAPPING
    function getColorFromPosition(x, y, z) {
      const size = 320;
      // Normalize to [-1,1] then to [0,1]
      let nx = Math.max(-1, Math.min(1, x / size));
      let ny = Math.max(-1, Math.min(1, y / size));
      let nz = Math.max(-1, Math.min(1, z / size));
      
      nx = (nx + 1) / 2;
      ny = (ny + 1) / 2;
      nz = (nz + 1) / 2;
      
      // Map to RGB corners
      const r = nx;
      const g = ny;
      const b = nz;
      
      // Convert RGB to HSL
      function rgb2hsl(r, g, b) {
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0;
        } else {
          let d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        return [h * 360, s * 100, Math.min(80, l * 100 + 20)];
      }
      
      const [h, s, l] = rgb2hsl(r, g, b);
      return `hsl(${h.toFixed(1)},${Math.max(50, s.toFixed(1))}%,${l.toFixed(1)}%)`;
    }

    class Vector {
      constructor() {
        this.startX = 0; this.startY = 0; this.startZ = 0;
        this.endX = (Math.random() - 0.5) * 640;
        this.endY = (Math.random() - 0.5) * 640;
        this.endZ = (Math.random() - 0.5) * 640;
        this.currentX = 0; this.currentY = 0; this.currentZ = 0;
        this.growth = 0;
        this.growthSpeed = Math.random() * 0.15 + 0.11;
        this.isComplete = false;
        this.color = getColorFromPosition(this.endX, this.endY, this.endZ);
      }
      update() {
        if (!this.isComplete) {
          this.growth += this.growthSpeed;
          if (this.growth >= 1) {
            this.growth = 1;
            this.isComplete = true;
            endpoints.push({
              x: this.endX, y: this.endY, z: this.endZ,
              color: this.color,
              size: Math.random() * 5 + 2.5
            });
          }
          this.currentX = this.startX + (this.endX - this.startX) * this.growth;
          this.currentY = this.startY + (this.endY - this.startY) * this.growth;
          this.currentZ = this.startZ + (this.endZ - this.startZ) * this.growth;
        }
        return !this.isComplete;
      }
      draw() {
        const start = project3D(this.startX, this.startY, this.startZ);
        const tip = project3D(this.currentX, this.currentY, this.currentZ);
        ctx.save();
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2.2;
        ctx.globalAlpha = 0.86;
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(tip.x, tip.y);
        ctx.stroke();
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 11;
        ctx.beginPath();
        ctx.arc(tip.x, tip.y, 3.5 * tip.scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function draw3DCoordinateSystem() {
      const axisLength = 320;
      ctx.save();
      ctx.lineWidth = 1.1;
      ctx.strokeStyle = "rgba(255,60,60,0.23)";
      ctx.beginPath();
      let s = project3D(0, 0, 0), e = project3D(axisLength, 0, 0);
      ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
      e = project3D(-axisLength, 0, 0);
      ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
      ctx.stroke();
      ctx.strokeStyle = "rgba(60,255,60,0.23)";
      ctx.beginPath();
      e = project3D(0, axisLength, 0);
      ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
      e = project3D(0, -axisLength, 0);
      ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
      ctx.stroke();
      ctx.strokeStyle = "rgba(60,60,255,0.23)";
      ctx.beginPath();
      e = project3D(0, 0, axisLength);
      ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
      e = project3D(0, 0, -axisLength);
      ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
      ctx.stroke();
      ctx.globalAlpha = 0.82;
      ctx.fillStyle = "#fff";
      ctx.shadowColor = "#fff";
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(s.x, s.y, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawEndpoints() {
      const sorted = [...endpoints].sort((a,b) => b.z - a.z);
      for (let endpoint of sorted) {
        const proj = project3D(endpoint.x, endpoint.y, endpoint.z);
        if (proj.x >= -60 && proj.x <= width+60 && proj.y >= -60 && proj.y <= height+60) {
          ctx.save();
          ctx.fillStyle = endpoint.color;
          ctx.shadowColor = endpoint.color;
          ctx.shadowBlur = 15;
          ctx.globalAlpha = Math.max(0.36, proj.scale);
          const size = endpoint.size * proj.scale;
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, size, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.fillStyle = "#fff8";
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, size*0.28, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      }
    }

    function animate() {
      ctx.fillStyle = "rgba(0,0,0,0.05)";
      ctx.fillRect(0,0,width,height);
      draw3DCoordinateSystem();
      vectors = vectors.filter(v => {
        const anim = v.update();
        v.draw();
        return anim;
      });
      drawEndpoints();
      if (Math.random() < 0.22 && vectors.length < 14) {
        vectors.push(new Vector());
      }
      time += 0.01;
      requestAnimationFrame(animate);
    }

    function showRipple() {
      let ripple = document.createElement('div');
      ripple.className = 'ripple';
      document.body.appendChild(ripple);
      setTimeout(() => { ripple.remove(); }, 510);
    }

    canvas.addEventListener('mousedown', (e) => {
      mouseDown = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      canvas.style.cursor = "grabbing";
    });
    canvas.addEventListener('mousemove', (e) => {
      if (mouseDown) {
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        rotationY += dx * 0.01;
        rotationX += dy * 0.01;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
    });
    canvas.addEventListener('mouseup', (e) => {
      mouseDown = false;
      canvas.style.cursor = "grab";
    });
    canvas.addEventListener('mouseleave', () => {
      mouseDown = false;
      canvas.style.cursor = "grab";
    });

    canvas.addEventListener('click', (e) => {
      if (!mouseDown) {
        vectors.push(new Vector());
        showRipple();
      }
    });

    canvas.addEventListener('touchstart', (e) => {
      isTouch = true;
      e.preventDefault();
      const touch = e.touches[0];
      mouseDown = true;
      lastMouseX = touch.clientX;
      lastMouseY = touch.clientY;
      canvas.style.cursor = "grabbing";
    });
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (mouseDown) {
        const touch = e.touches[0];
        const dx = touch.clientX - lastMouseX;
        const dy = touch.clientY - lastMouseY;
        rotationY += dx * 0.012;
        rotationX += dy * 0.012;
        lastMouseX = touch.clientX;
        lastMouseY = touch.clientY;
      }
    });
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      mouseDown = false;
      canvas.style.cursor = "grab";
      if (e.changedTouches.length === 1) {
        vectors.push(new Vector());
        showRipple();
      }
    });

    canvas.addEventListener('mouseenter', () => { if (!mouseDown) canvas.style.cursor = "grab"; });
    canvas.addEventListener('mouseleave', () => { canvas.style.cursor = "grab"; });

    window.addEventListener('resize', resize);

    resize();
    animate();

  </script>
</body>
</html>
